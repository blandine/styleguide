angular.module('wfm.components.timepicker', [
])
    .directive('wfmTimepicker', timepickerDirective)
    .directive('minuteInput', minuteInputDirective)
    .directive('hourInput', hourInputDirective);



function timepickerDirective() {

    return {
	restrict: 'E',
	template: '<input type="text">',
	controller: timepickerCtrl,
	link: postLink
    };

    function timepickerCtrl($scope, $element, $attrs) {
	var self = this;
	
	self.useMeridian = angular.isDefined($attrs.useMeridian) && $attrs.useMeridian;
	self.ceiling = {
	    hour: self.useMeridian? 12 : 24,
	    minute: 60,
	    meridian: self.useMeridian? 2 : 0	    
	};

	self.changeByKeyPress = function(evt, ngModel, ceiling) {
	    evt.preventDefault();
	    var action;
	    if (evt.which === 38) {
		action = increment;
	    } else if (evt.which === 40) {
		action = decrement;
	    }
	    if (action) {
		ngModel.$setViewValue(action(ngModel.$modelValue, ceiling));
		ngModel.$render();
	    }	    
	};

	self.changeByMouseWheel = function(evt, ngModel, ceiling) {
	    evt.preventDefault();
	    var isScrollingUp = function(e) {
		if (e.originalEvent) {
		    e = e.originalEvent;
		}
		//pick correct delta variable depending on event
		var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
		return (e.detail || delta > 0);
	    };
	    var action = isScrollingUp(evt)? increment: decrement;
	    if (action) {
		ngModel.$setViewValue(action(ngModel.$modelValue, ceiling));
		ngModel.$render();
	    }	    
	};
	
	function increment(value, ceiling) {
	    if (!value) return 1;
	    var newValue = value + 1;
	    return (newValue >= ceiling)? newValue - ceiling: newValue;	    
	}

	function decrement(value, ceiling) {
	    if (!value) return ceiling - 1;
	    var newValue = value - 1;
	    return (newValue < 0 )? newValue + ceiling : newValue;
	}			
	
    }

    function postLink(scope, elem, attrs) {
	

	
    }
    
}


function hourInputDirective() {

    return {	
	require: ['ngModel', '^wfmTimepicker'],
	restrict: 'A',
	link: postLink
    };

    function postLink(scope, elem, attrs, ctrls) {

	var ngModel = ctrls[0];
	var wfmTimepicker = ctrls[1];


	elem.attr('placeholder', wfmTimepicker.showMeridian? 'hh' : 'HH');
	elem.bind('focus', onFocus);
	elem.bind('blur', onBlur);
	

	function changeByKeyPress(evt) {
	    wfmTimepicker.changeByKeyPress(evt, ngModel, wfmTimepicker.ceiling.hour);
	}

	function changeByMouseWheel(evt) {
	    wfmTimepicker.changeByMouseWheel(evt, ngModel, wfmTimepicker.ceiling.hour);
	}
	

	function onFocus(evt) {
	    elem.bind('keydown', changeByKeyPress);
	    elem.bind('mousewheel wheel', changeByMouseWheel);
	}

	function onBlur(evt) {
	    elem.unbind('keydown', changeByKeyPress);
	    elem.unbind('mousewheel wheel', changeByMouseWheel);	    
	}
		
    }    
}

function minuteInputDirective() {
    return {
	restrict: 'A',
	require: ['ngModel', '^wfmTimepicker'],
	link: postLink
    };

    function postLink(scope, elem, attrs, ctrls) {
	var ngModel = ctrls[0];
	var wfmTimepicker = ctrls[1];


	elem.attr('placeholder', 'mm');
	elem.bind('focus', onFocus);
	elem.bind('blur', onBlur);
	

	function changeByKeyPress(evt) {
	    wfmTimepicker.changeByKeyPress(evt, ngModel, wfmTimepicker.ceiling.minute);
	}

	function changeByMouseWheel(evt) {
	    wfmTimepicker.changeByMouseWheel(evt, ngModel, wfmTimepicker.ceiling.minute);
	}
	

	function onFocus(evt) {
	    elem.bind('keydown', changeByKeyPress);
	    elem.bind('mousewheel wheel', changeByMouseWheel);
	}

	function onBlur(evt) {
	    elem.unbind('keydown', changeByKeyPress);
	    elem.unbind('mousewheel wheel', changeByMouseWheel);	    
	}		
    }
    
}
